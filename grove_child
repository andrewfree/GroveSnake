#!/usr/bin/env python2.7
import subprocess 
import os
import traceback
import string

import gntp.notifier
from appscript import *

# import urllib2, httplib, json # Can get json metadata on youtube videos w/ http://gdata.youtube.com/feeds/api/videos/_7gcIbopIPk?v=2&alt=json
# import soundcloud,client = soundcloud.Client(client_id='*',client_secret='*',username='*',password='*')

def sendGrowlNotify(message,callback_url="http://youtube.com",code="",msg_priority=0,msg_type="New Download"):
    # https://github.com/kfdm/gntp/blob/master/docs/index.rst    
    growl = gntp.notifier.GrowlNotifier(
        applicationName = "GroveSnake",
        notifications = ["Completed","New Download"],
        defaultNotifications = ["New Download"]
    )
    growl.register()
    growl.notify(
        noteType = msg_type,
        title = "%s" % message,
        description = "%s" % code,
        icon = "http://i.imgur.com/mXcrWGf.png", # http://i.imgur.com/cc0OCEo.png, http://i.imgur.com/Bfz3kgL.png?1
        sticky = False,
        priority = msg_priority,
        callback = callback_url
    )

def sizeof_formatter(num):
    for x in ['bytes','KB','MB','GB','TB']:
        if num < 1024.0:
            return "%3.1f %s" % (num, x)
        num /= 1024.0

def main():
    try:
        provider = ""
        meta_tagged = False
        clipboard_process = subprocess.Popen("pbpaste", stdout=subprocess.PIPE)
        clipboard_link, err = clipboard_process.communicate()

        # Verify link being used is from soundcloud or youtube
        if not (("youtube" in clipboard_link) or ("soundcloud" in clipboard_link)):
            print "invalid link"
            sendGrowlNotify("Bad Link!")
            os._exit(0)
        
        project_dir = (os.path.dirname(os.path.realpath(__file__))) # Project directory
        os.chdir(project_dir) # Change working directory to project directory (not nesessarly where it was launched from) 

        # Start download, max quality, safe filenames for handling below. The ID is in the filename so you can do metadata lookups for more info if wanted. Rips to mp3, might want to support native download formats, transcoding again and again lowers quality. 
        sendGrowlNotify("Fetching!")
        os.chdir(os.path.join("tracks"))
        youtube_dl = subprocess.Popen(["youtube-dl","--max-quality","--add-metadata","-o","%(title)s-%(id)s.%(ext)s","--extract-audio","--audio-format","mp3","--audio-quality","0",clipboard_link],stderr=subprocess.STDOUT,stdout=subprocess.PIPE)#--add-metadata # 


        for line in youtube_dl.communicate():
            if line == None:
                continue # No output yet.
            elif ("[ffmpeg] Destination:" in line) or ("Post-process" in line): # It sends all of youtube-dl in single line, so I check if there is this within
                for item in line.split("\n"): # Iterate youtube-dl output line by line (after it finished running)
                    if ("[ffmpeg] Destination:" in item) or ("Post-process" in item): # Then I find specific one 
                        if "[ffmpeg] Destination:" in item:
                            provider = "youtube"
                            filename_org = item.split("/")[-1].strip()
                            break
                        if (("Post-process" in item) and ("exists" in item) and ("soundcloud" in clipboard_link)): # Soundcloud always spits out "exists" in the postprocessing because the requested format (mp3) is what soundcloud returns through youtube-dl.
                            provider = "soundcloud"
                            tmp = item.split("/")[-1]

                            filename_org = tmp[28:tmp.find("exists")].strip()
                            break
                        else:
                            sendGrowlNotify(line)
                            print "Unknown Source"
                            sendGrowlNotify("Unknown Source...")
                            os._exit(1)
                    if (("JSON" in item) and ("soundcloud" in item)):
                        print "Found song metadata"
                        meta_tagged = True

        if provider == "youtube":
            artist,title = filename_org.split("-")[0:2] #song_id = filename_org.split("-")[-1].split(".")[0]
        elif provider == "soundcloud":
            if meta_tagged != True:
                artist,title = filename_org.split("-")[0:2] #song_id = filename_org.split("-")[-1].split(".")[0]
            else:
                artist,title = filename_org.split("-")[0:2] #song_id = filename_org.split("-")[-1].split(".")[0]
        else:
            print "Unknown Source"
            print provider
            sendGrowlNotify(provider)
            sendGrowlNotify("Unknown Source.",msg_priority=1)
            os._exit(1)

        # Tag Title-Artist and other metadata
        #file_path = os.path.realpath(os.path.join("tracks",filename_org))
        file_path = filename_org
        no_https_url = string.join(clipboard_link.split("/")[2:],"/") # Remove https part before adding to comment. https url screws with something metadata/finder related.
        size = sizeof_formatter(os.path.getsize(filename_org)) # Human readable
        
        # Writing id3v2 comment tags with clipboard url. Sometimes it comes pretagged (from soundcloud), should detect and perfer that later"
        if meta_tagged != True:
            subprocess.call(["id3v2","-t",title,"-a",artist,"-c",no_https_url,"%s" % file_path],stdout=subprocess.PIPE)
        else:
            subprocess.call(["id3v2","-c",no_https_url,"%s" % file_path],stdout=subprocess.PIPE)
        
        # Added metadata from source, not usefull right now.
        # subprocess.call(["xattr","-s","com.apple.metadata:kMDItemWhereFroms",provider,file_path],stdout=subprocess.PIPE,stderr=subprocess.PIPE)

        # Tag file for Hazel (OS X) to deal with.
        sendGrowlNotify("%s - %s" % (artist,title),code="%s" % size,callback_url = clipboard_link,msg_type="Completed")
        subprocess.Popen(["bash","setFileComments.sh",file_path],stdout=subprocess.PIPE,stderr=subprocess.PIPE)
        os._exit(0)
    
    except subprocess.CalledProcessError as e:
        print traceback.format_exc()
        sendGrowlNotify('Not able to catch error, popen failed uniquely',msg_priority=1)
        os._exit(1)
    
    except Exception, e:
        print traceback.format_exc()
        sendGrowlNotify("FAILED TO PROCESS | %s" % e,msg_priority=1,msg_type="Completed",code="404")
        os._exit(1)
    
if __name__ == '__main__':
    main()